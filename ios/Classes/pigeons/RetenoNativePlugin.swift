// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum NativeInAppMessageStatus: Int {
  case inAppShouldBeDisplayed = 0
  case inAppIsDisplayed = 1
  case inAppShouldBeClosed = 2
  case inAppIsClosed = 3
  case inAppReceivedError = 4
}

enum NativeRecomEventType: Int {
  case impression = 0
  case click = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRetenoUser {
  var userAttributes: NativeUserAttributes? = nil
  var subscriptionKeys: [String?]? = nil
  var groupNamesInclude: [String?]? = nil
  var groupNamesExclude: [String?]? = nil

  static func fromList(_ list: [Any?]) -> NativeRetenoUser? {
    var userAttributes: NativeUserAttributes? = nil
    if let userAttributesList: [Any?] = nilOrValue(list[0]) {
      userAttributes = NativeUserAttributes.fromList(userAttributesList)
    }
    let subscriptionKeys: [String?]? = nilOrValue(list[1])
    let groupNamesInclude: [String?]? = nilOrValue(list[2])
    let groupNamesExclude: [String?]? = nilOrValue(list[3])

    return NativeRetenoUser(
      userAttributes: userAttributes,
      subscriptionKeys: subscriptionKeys,
      groupNamesInclude: groupNamesInclude,
      groupNamesExclude: groupNamesExclude
    )
  }
  func toList() -> [Any?] {
    return [
      userAttributes?.toList(),
      subscriptionKeys,
      groupNamesInclude,
      groupNamesExclude,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserAttributes {
  var phone: String? = nil
  var email: String? = nil
  var firstName: String? = nil
  var lastName: String? = nil
  var languageCode: String? = nil
  var timeZone: String? = nil
  var address: NativeAddress? = nil
  var fields: [NativeUserCustomField?]? = nil

  static func fromList(_ list: [Any?]) -> NativeUserAttributes? {
    let phone: String? = nilOrValue(list[0])
    let email: String? = nilOrValue(list[1])
    let firstName: String? = nilOrValue(list[2])
    let lastName: String? = nilOrValue(list[3])
    let languageCode: String? = nilOrValue(list[4])
    let timeZone: String? = nilOrValue(list[5])
    var address: NativeAddress? = nil
    if let addressList: [Any?] = nilOrValue(list[6]) {
      address = NativeAddress.fromList(addressList)
    }
    let fields: [NativeUserCustomField?]? = nilOrValue(list[7])

    return NativeUserAttributes(
      phone: phone,
      email: email,
      firstName: firstName,
      lastName: lastName,
      languageCode: languageCode,
      timeZone: timeZone,
      address: address,
      fields: fields
    )
  }
  func toList() -> [Any?] {
    return [
      phone,
      email,
      firstName,
      lastName,
      languageCode,
      timeZone,
      address?.toList(),
      fields,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAddress {
  var region: String? = nil
  var town: String? = nil
  var address: String? = nil
  var postcode: String? = nil

  static func fromList(_ list: [Any?]) -> NativeAddress? {
    let region: String? = nilOrValue(list[0])
    let town: String? = nilOrValue(list[1])
    let address: String? = nilOrValue(list[2])
    let postcode: String? = nilOrValue(list[3])

    return NativeAddress(
      region: region,
      town: town,
      address: address,
      postcode: postcode
    )
  }
  func toList() -> [Any?] {
    return [
      region,
      town,
      address,
      postcode,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserCustomField {
  var key: String
  var value: String? = nil

  static func fromList(_ list: [Any?]) -> NativeUserCustomField? {
    let key = list[0] as! String
    let value: String? = nilOrValue(list[1])

    return NativeUserCustomField(
      key: key,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      key,
      value,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAnonymousUserAttributes {
  var firstName: String? = nil
  var lastName: String? = nil
  var languageCode: String? = nil
  var timeZone: String? = nil
  var address: NativeAddress? = nil
  var fields: [NativeUserCustomField?]? = nil

  static func fromList(_ list: [Any?]) -> NativeAnonymousUserAttributes? {
    let firstName: String? = nilOrValue(list[0])
    let lastName: String? = nilOrValue(list[1])
    let languageCode: String? = nilOrValue(list[2])
    let timeZone: String? = nilOrValue(list[3])
    var address: NativeAddress? = nil
    if let addressList: [Any?] = nilOrValue(list[4]) {
      address = NativeAddress.fromList(addressList)
    }
    let fields: [NativeUserCustomField?]? = nilOrValue(list[5])

    return NativeAnonymousUserAttributes(
      firstName: firstName,
      lastName: lastName,
      languageCode: languageCode,
      timeZone: timeZone,
      address: address,
      fields: fields
    )
  }
  func toList() -> [Any?] {
    return [
      firstName,
      lastName,
      languageCode,
      timeZone,
      address?.toList(),
      fields,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeCustomEvent {
  var eventTypeKey: String
  var dateOccurred: String
  var parameters: [NativeCustomEventParameter?]
  var forcePush: Bool

  static func fromList(_ list: [Any?]) -> NativeCustomEvent? {
    let eventTypeKey = list[0] as! String
    let dateOccurred = list[1] as! String
    let parameters = list[2] as! [NativeCustomEventParameter?]
    let forcePush = list[3] as! Bool

    return NativeCustomEvent(
      eventTypeKey: eventTypeKey,
      dateOccurred: dateOccurred,
      parameters: parameters,
      forcePush: forcePush
    )
  }
  func toList() -> [Any?] {
    return [
      eventTypeKey,
      dateOccurred,
      parameters,
      forcePush,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeCustomEventParameter {
  var name: String
  var value: String? = nil

  static func fromList(_ list: [Any?]) -> NativeCustomEventParameter? {
    let name = list[0] as! String
    let value: String? = nilOrValue(list[1])

    return NativeCustomEventParameter(
      name: name,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      value,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeInAppMessageAction {
  var isCloseButtonClicked: Bool
  var isButtonClicked: Bool
  var isOpenUrlClicked: Bool

  static func fromList(_ list: [Any?]) -> NativeInAppMessageAction? {
    let isCloseButtonClicked = list[0] as! Bool
    let isButtonClicked = list[1] as! Bool
    let isOpenUrlClicked = list[2] as! Bool

    return NativeInAppMessageAction(
      isCloseButtonClicked: isCloseButtonClicked,
      isButtonClicked: isButtonClicked,
      isOpenUrlClicked: isOpenUrlClicked
    )
  }
  func toList() -> [Any?] {
    return [
      isCloseButtonClicked,
      isButtonClicked,
      isOpenUrlClicked,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecomFilter {
  var name: String
  var values: [String?]

  static func fromList(_ list: [Any?]) -> NativeRecomFilter? {
    let name = list[0] as! String
    let values = list[1] as! [String?]

    return NativeRecomFilter(
      name: name,
      values: values
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      values,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecommendation {
  var productId: String
  var name: String? = nil
  var description: String? = nil
  var imageUrl: String? = nil
  var price: Double? = nil

  static func fromList(_ list: [Any?]) -> NativeRecommendation? {
    let productId = list[0] as! String
    let name: String? = nilOrValue(list[1])
    let description: String? = nilOrValue(list[2])
    let imageUrl: String? = nilOrValue(list[3])
    let price: Double? = nilOrValue(list[4])

    return NativeRecommendation(
      productId: productId,
      name: name,
      description: description,
      imageUrl: imageUrl,
      price: price
    )
  }
  func toList() -> [Any?] {
    return [
      productId,
      name,
      description,
      imageUrl,
      price,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecomEvent {
  var eventType: NativeRecomEventType
  var dateOccurred: String
  var productId: String

  static func fromList(_ list: [Any?]) -> NativeRecomEvent? {
    let eventType = NativeRecomEventType(rawValue: list[0] as! Int)!
    let dateOccurred = list[1] as! String
    let productId = list[2] as! String

    return NativeRecomEvent(
      eventType: eventType,
      dateOccurred: dateOccurred,
      productId: productId
    )
  }
  func toList() -> [Any?] {
    return [
      eventType.rawValue,
      dateOccurred,
      productId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecomEvents {
  var recomVariantId: String
  var events: [NativeRecomEvent?]

  static func fromList(_ list: [Any?]) -> NativeRecomEvents? {
    let recomVariantId = list[0] as! String
    let events = list[1] as! [NativeRecomEvent?]

    return NativeRecomEvents(
      recomVariantId: recomVariantId,
      events: events
    )
  }
  func toList() -> [Any?] {
    return [
      recomVariantId,
      events,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLifecycleTrackingOptions {
  var appLifecycleEnabled: Bool
  var pushSubscriptionEnabled: Bool
  var sessionEventsEnabled: Bool

  static func fromList(_ list: [Any?]) -> NativeLifecycleTrackingOptions? {
    let appLifecycleEnabled = list[0] as! Bool
    let pushSubscriptionEnabled = list[1] as! Bool
    let sessionEventsEnabled = list[2] as! Bool

    return NativeLifecycleTrackingOptions(
      appLifecycleEnabled: appLifecycleEnabled,
      pushSubscriptionEnabled: pushSubscriptionEnabled,
      sessionEventsEnabled: sessionEventsEnabled
    )
  }
  func toList() -> [Any?] {
    return [
      appLifecycleEnabled,
      pushSubscriptionEnabled,
      sessionEventsEnabled,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAppInboxMessages {
  var messages: [NativeAppInboxMessage?]
  var totalPages: Int64

  static func fromList(_ list: [Any?]) -> NativeAppInboxMessages? {
    let messages = list[0] as! [NativeAppInboxMessage?]
    let totalPages = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)

    return NativeAppInboxMessages(
      messages: messages,
      totalPages: totalPages
    )
  }
  func toList() -> [Any?] {
    return [
      messages,
      totalPages,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAppInboxMessage {
  var id: String
  var title: String
  var createdDate: String
  var isNewMessage: Bool
  var content: String? = nil
  var imageUrl: String? = nil
  var linkUrl: String? = nil
  var category: String? = nil

  static func fromList(_ list: [Any?]) -> NativeAppInboxMessage? {
    let id = list[0] as! String
    let title = list[1] as! String
    let createdDate = list[2] as! String
    let isNewMessage = list[3] as! Bool
    let content: String? = nilOrValue(list[4])
    let imageUrl: String? = nilOrValue(list[5])
    let linkUrl: String? = nilOrValue(list[6])
    let category: String? = nilOrValue(list[7])

    return NativeAppInboxMessage(
      id: id,
      title: title,
      createdDate: createdDate,
      isNewMessage: isNewMessage,
      content: content,
      imageUrl: imageUrl,
      linkUrl: linkUrl,
      category: category
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      createdDate,
      isNewMessage,
      content,
      imageUrl,
      linkUrl,
      category,
    ]
  }
}

private class RetenoHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return NativeAddress.fromList(self.readValue() as! [Any?])
    case 129:
      return NativeAnonymousUserAttributes.fromList(self.readValue() as! [Any?])
    case 130:
      return NativeAppInboxMessage.fromList(self.readValue() as! [Any?])
    case 131:
      return NativeAppInboxMessages.fromList(self.readValue() as! [Any?])
    case 132:
      return NativeCustomEvent.fromList(self.readValue() as! [Any?])
    case 133:
      return NativeCustomEventParameter.fromList(self.readValue() as! [Any?])
    case 134:
      return NativeInAppMessageAction.fromList(self.readValue() as! [Any?])
    case 135:
      return NativeLifecycleTrackingOptions.fromList(self.readValue() as! [Any?])
    case 136:
      return NativeRecomEvent.fromList(self.readValue() as! [Any?])
    case 137:
      return NativeRecomEvents.fromList(self.readValue() as! [Any?])
    case 138:
      return NativeRecomFilter.fromList(self.readValue() as! [Any?])
    case 139:
      return NativeRecommendation.fromList(self.readValue() as! [Any?])
    case 140:
      return NativeRetenoUser.fromList(self.readValue() as! [Any?])
    case 141:
      return NativeUserAttributes.fromList(self.readValue() as! [Any?])
    case 142:
      return NativeUserCustomField.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class RetenoHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? NativeAddress {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAnonymousUserAttributes {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAppInboxMessage {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAppInboxMessages {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NativeCustomEvent {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NativeCustomEventParameter {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? NativeInAppMessageAction {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLifecycleTrackingOptions {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomEvent {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomEvents {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomFilter {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecommendation {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRetenoUser {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserAttributes {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserCustomField {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RetenoHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RetenoHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RetenoHostApiCodecWriter(data: data)
  }
}

class RetenoHostApiCodec: FlutterStandardMessageCodec {
  static let shared = RetenoHostApiCodec(readerWriter: RetenoHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol RetenoHostApi {
  func initWith(accessKey: String, lifecycleTrackingOptions: NativeLifecycleTrackingOptions?, isPausedInAppMessages: Bool, useCustomDeviceIdProvider: Bool) throws
  func setUserAttributes(externalUserId: String, user: NativeRetenoUser?) throws
  func setAnonymousUserAttributes(anonymousUserAttributes: NativeAnonymousUserAttributes) throws
  func logEvent(event: NativeCustomEvent) throws
  func updatePushPermissionStatus() throws
  func pauseInAppMessages(isPaused: Bool) throws
  func getInitialNotification() throws -> [String: Any]?
  func getRecommendations(recomVariantId: String, productIds: [String], categoryId: String, filters: [NativeRecomFilter]?, fields: [String]?, completion: @escaping (Result<[NativeRecommendation], Error>) -> Void)
  func logRecommendationsEvent(events: NativeRecomEvents) throws
  func getAppInboxMessages(page: Int64?, pageSize: Int64?, completion: @escaping (Result<NativeAppInboxMessages, Error>) -> Void)
  func getAppInboxMessagesCount(completion: @escaping (Result<Int64, Error>) -> Void)
  func markAsOpened(messageId: String) throws
  func markAllMessagesAsOpened(completion: @escaping (Result<Void, Error>) -> Void)
  func subscribeOnMessagesCountChanged() throws
  func unsubscribeAllMessagesCountChanged() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class RetenoHostApiSetup {
  /// The codec used by RetenoHostApi.
  static var codec: FlutterStandardMessageCodec { RetenoHostApiCodec.shared }
  /// Sets up an instance of `RetenoHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: RetenoHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initWithChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.initWith\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initWithChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let accessKeyArg = args[0] as! String
        let lifecycleTrackingOptionsArg: NativeLifecycleTrackingOptions? = nilOrValue(args[1])
        let isPausedInAppMessagesArg = args[2] as! Bool
        let useCustomDeviceIdProviderArg = args[3] as! Bool
        do {
          try api.initWith(accessKey: accessKeyArg, lifecycleTrackingOptions: lifecycleTrackingOptionsArg, isPausedInAppMessages: isPausedInAppMessagesArg, useCustomDeviceIdProvider: useCustomDeviceIdProviderArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initWithChannel.setMessageHandler(nil)
    }
    let setUserAttributesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.setUserAttributes\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUserAttributesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let externalUserIdArg = args[0] as! String
        let userArg: NativeRetenoUser? = nilOrValue(args[1])
        do {
          try api.setUserAttributes(externalUserId: externalUserIdArg, user: userArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserAttributesChannel.setMessageHandler(nil)
    }
    let setAnonymousUserAttributesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.setAnonymousUserAttributes\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnonymousUserAttributesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anonymousUserAttributesArg = args[0] as! NativeAnonymousUserAttributes
        do {
          try api.setAnonymousUserAttributes(anonymousUserAttributes: anonymousUserAttributesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAnonymousUserAttributesChannel.setMessageHandler(nil)
    }
    let logEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEvent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! NativeCustomEvent
        do {
          try api.logEvent(event: eventArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEventChannel.setMessageHandler(nil)
    }
    let updatePushPermissionStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.updatePushPermissionStatus\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updatePushPermissionStatusChannel.setMessageHandler { _, reply in
        do {
          try api.updatePushPermissionStatus()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updatePushPermissionStatusChannel.setMessageHandler(nil)
    }
    let pauseInAppMessagesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.pauseInAppMessages\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseInAppMessagesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let isPausedArg = args[0] as! Bool
        do {
          try api.pauseInAppMessages(isPaused: isPausedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseInAppMessagesChannel.setMessageHandler(nil)
    }
    let getInitialNotificationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getInitialNotification\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getInitialNotificationChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getInitialNotification()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getInitialNotificationChannel.setMessageHandler(nil)
    }
    let getRecommendationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getRecommendations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getRecommendationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let recomVariantIdArg = args[0] as! String
        let productIdsArg = args[1] as! [String]
        let categoryIdArg = args[2] as! String
        let filtersArg: [NativeRecomFilter]? = nilOrValue(args[3])
        let fieldsArg: [String]? = nilOrValue(args[4])
        api.getRecommendations(recomVariantId: recomVariantIdArg, productIds: productIdsArg, categoryId: categoryIdArg, filters: filtersArg, fields: fieldsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getRecommendationsChannel.setMessageHandler(nil)
    }
    let logRecommendationsEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logRecommendationsEvent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logRecommendationsEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventsArg = args[0] as! NativeRecomEvents
        do {
          try api.logRecommendationsEvent(events: eventsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logRecommendationsEventChannel.setMessageHandler(nil)
    }
    let getAppInboxMessagesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getAppInboxMessages\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAppInboxMessagesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageArg: Int64? = isNullish(args[0]) ? nil : (args[0] is Int64? ? args[0] as! Int64? : Int64(args[0] as! Int32))
        let pageSizeArg: Int64? = isNullish(args[1]) ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        api.getAppInboxMessages(page: pageArg, pageSize: pageSizeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAppInboxMessagesChannel.setMessageHandler(nil)
    }
    let getAppInboxMessagesCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getAppInboxMessagesCount\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAppInboxMessagesCountChannel.setMessageHandler { _, reply in
        api.getAppInboxMessagesCount { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAppInboxMessagesCountChannel.setMessageHandler(nil)
    }
    let markAsOpenedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.markAsOpened\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      markAsOpenedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let messageIdArg = args[0] as! String
        do {
          try api.markAsOpened(messageId: messageIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      markAsOpenedChannel.setMessageHandler(nil)
    }
    let markAllMessagesAsOpenedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.markAllMessagesAsOpened\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      markAllMessagesAsOpenedChannel.setMessageHandler { _, reply in
        api.markAllMessagesAsOpened { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      markAllMessagesAsOpenedChannel.setMessageHandler(nil)
    }
    let subscribeOnMessagesCountChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.subscribeOnMessagesCountChanged\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      subscribeOnMessagesCountChangedChannel.setMessageHandler { _, reply in
        do {
          try api.subscribeOnMessagesCountChanged()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      subscribeOnMessagesCountChangedChannel.setMessageHandler(nil)
    }
    let unsubscribeAllMessagesCountChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.unsubscribeAllMessagesCountChanged\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unsubscribeAllMessagesCountChangedChannel.setMessageHandler { _, reply in
        do {
          try api.unsubscribeAllMessagesCountChanged()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unsubscribeAllMessagesCountChangedChannel.setMessageHandler(nil)
    }
  }
}
private class RetenoFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return NativeAddress.fromList(self.readValue() as! [Any?])
    case 129:
      return NativeAnonymousUserAttributes.fromList(self.readValue() as! [Any?])
    case 130:
      return NativeAppInboxMessage.fromList(self.readValue() as! [Any?])
    case 131:
      return NativeAppInboxMessages.fromList(self.readValue() as! [Any?])
    case 132:
      return NativeCustomEvent.fromList(self.readValue() as! [Any?])
    case 133:
      return NativeCustomEventParameter.fromList(self.readValue() as! [Any?])
    case 134:
      return NativeInAppMessageAction.fromList(self.readValue() as! [Any?])
    case 135:
      return NativeLifecycleTrackingOptions.fromList(self.readValue() as! [Any?])
    case 136:
      return NativeRecomEvent.fromList(self.readValue() as! [Any?])
    case 137:
      return NativeRecomEvents.fromList(self.readValue() as! [Any?])
    case 138:
      return NativeRecomFilter.fromList(self.readValue() as! [Any?])
    case 139:
      return NativeRecommendation.fromList(self.readValue() as! [Any?])
    case 140:
      return NativeRetenoUser.fromList(self.readValue() as! [Any?])
    case 141:
      return NativeUserAttributes.fromList(self.readValue() as! [Any?])
    case 142:
      return NativeUserCustomField.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class RetenoFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? NativeAddress {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAnonymousUserAttributes {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAppInboxMessage {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAppInboxMessages {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NativeCustomEvent {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NativeCustomEventParameter {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? NativeInAppMessageAction {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLifecycleTrackingOptions {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomEvent {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomEvents {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomFilter {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecommendation {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRetenoUser {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserAttributes {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserCustomField {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RetenoFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RetenoFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RetenoFlutterApiCodecWriter(data: data)
  }
}

class RetenoFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = RetenoFlutterApiCodec(readerWriter: RetenoFlutterApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol RetenoFlutterApiProtocol {
  func onNotificationReceived(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onNotificationClicked(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onInAppMessageStatusChanged(status statusArg: NativeInAppMessageStatus, action actionArg: NativeInAppMessageAction?, error errorArg: String?, completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onMessagesCountChanged(count countArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)
  func getDeviceId(completion: @escaping (Result<String?, FlutterError>) -> Void)
}
class RetenoFlutterApi: RetenoFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: FlutterStandardMessageCodec {
    return RetenoFlutterApiCodec.shared
  }
  func onNotificationReceived(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onNotificationReceived\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([payloadArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onNotificationClicked(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onNotificationClicked\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([payloadArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onInAppMessageStatusChanged(status statusArg: NativeInAppMessageStatus, action actionArg: NativeInAppMessageAction?, error errorArg: String?, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onInAppMessageStatusChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([statusArg.rawValue, actionArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onMessagesCountChanged(count countArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onMessagesCountChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([countArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func getDeviceId(completion: @escaping (Result<String?, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.getDeviceId\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        let result: String? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
}
