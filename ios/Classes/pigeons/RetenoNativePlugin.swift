// Autogenerated from Pigeon (v26.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsRetenoNativePlugin(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsRetenoNativePlugin(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsRetenoNativePlugin(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashRetenoNativePlugin(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashRetenoNativePlugin(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashRetenoNativePlugin(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

enum NativeInAppMessageStatus: Int {
  case inAppShouldBeDisplayed = 0
  case inAppIsDisplayed = 1
  case inAppShouldBeClosed = 2
  case inAppIsClosed = 3
  case inAppReceivedError = 4
}

enum NativeRecomEventType: Int {
  case impression = 0
  case click = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRetenoUser: Hashable {
  var userAttributes: NativeUserAttributes? = nil
  var subscriptionKeys: [String?]? = nil
  var groupNamesInclude: [String?]? = nil
  var groupNamesExclude: [String?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeRetenoUser? {
    let userAttributes: NativeUserAttributes? = nilOrValue(pigeonVar_list[0])
    let subscriptionKeys: [String?]? = nilOrValue(pigeonVar_list[1])
    let groupNamesInclude: [String?]? = nilOrValue(pigeonVar_list[2])
    let groupNamesExclude: [String?]? = nilOrValue(pigeonVar_list[3])

    return NativeRetenoUser(
      userAttributes: userAttributes,
      subscriptionKeys: subscriptionKeys,
      groupNamesInclude: groupNamesInclude,
      groupNamesExclude: groupNamesExclude
    )
  }
  func toList() -> [Any?] {
    return [
      userAttributes,
      subscriptionKeys,
      groupNamesInclude,
      groupNamesExclude,
    ]
  }
  static func == (lhs: NativeRetenoUser, rhs: NativeRetenoUser) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserAttributes: Hashable {
  var phone: String? = nil
  var email: String? = nil
  var firstName: String? = nil
  var lastName: String? = nil
  var languageCode: String? = nil
  var timeZone: String? = nil
  var address: NativeAddress? = nil
  var fields: [NativeUserCustomField?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeUserAttributes? {
    let phone: String? = nilOrValue(pigeonVar_list[0])
    let email: String? = nilOrValue(pigeonVar_list[1])
    let firstName: String? = nilOrValue(pigeonVar_list[2])
    let lastName: String? = nilOrValue(pigeonVar_list[3])
    let languageCode: String? = nilOrValue(pigeonVar_list[4])
    let timeZone: String? = nilOrValue(pigeonVar_list[5])
    let address: NativeAddress? = nilOrValue(pigeonVar_list[6])
    let fields: [NativeUserCustomField?]? = nilOrValue(pigeonVar_list[7])

    return NativeUserAttributes(
      phone: phone,
      email: email,
      firstName: firstName,
      lastName: lastName,
      languageCode: languageCode,
      timeZone: timeZone,
      address: address,
      fields: fields
    )
  }
  func toList() -> [Any?] {
    return [
      phone,
      email,
      firstName,
      lastName,
      languageCode,
      timeZone,
      address,
      fields,
    ]
  }
  static func == (lhs: NativeUserAttributes, rhs: NativeUserAttributes) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAddress: Hashable {
  var region: String? = nil
  var town: String? = nil
  var address: String? = nil
  var postcode: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeAddress? {
    let region: String? = nilOrValue(pigeonVar_list[0])
    let town: String? = nilOrValue(pigeonVar_list[1])
    let address: String? = nilOrValue(pigeonVar_list[2])
    let postcode: String? = nilOrValue(pigeonVar_list[3])

    return NativeAddress(
      region: region,
      town: town,
      address: address,
      postcode: postcode
    )
  }
  func toList() -> [Any?] {
    return [
      region,
      town,
      address,
      postcode,
    ]
  }
  static func == (lhs: NativeAddress, rhs: NativeAddress) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserCustomField: Hashable {
  var key: String
  var value: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeUserCustomField? {
    let key = pigeonVar_list[0] as! String
    let value: String? = nilOrValue(pigeonVar_list[1])

    return NativeUserCustomField(
      key: key,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      key,
      value,
    ]
  }
  static func == (lhs: NativeUserCustomField, rhs: NativeUserCustomField) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAnonymousUserAttributes: Hashable {
  var firstName: String? = nil
  var lastName: String? = nil
  var languageCode: String? = nil
  var timeZone: String? = nil
  var address: NativeAddress? = nil
  var fields: [NativeUserCustomField?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeAnonymousUserAttributes? {
    let firstName: String? = nilOrValue(pigeonVar_list[0])
    let lastName: String? = nilOrValue(pigeonVar_list[1])
    let languageCode: String? = nilOrValue(pigeonVar_list[2])
    let timeZone: String? = nilOrValue(pigeonVar_list[3])
    let address: NativeAddress? = nilOrValue(pigeonVar_list[4])
    let fields: [NativeUserCustomField?]? = nilOrValue(pigeonVar_list[5])

    return NativeAnonymousUserAttributes(
      firstName: firstName,
      lastName: lastName,
      languageCode: languageCode,
      timeZone: timeZone,
      address: address,
      fields: fields
    )
  }
  func toList() -> [Any?] {
    return [
      firstName,
      lastName,
      languageCode,
      timeZone,
      address,
      fields,
    ]
  }
  static func == (lhs: NativeAnonymousUserAttributes, rhs: NativeAnonymousUserAttributes) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeCustomEvent: Hashable {
  var eventTypeKey: String
  var dateOccurred: String
  var parameters: [NativeCustomEventParameter?]
  var forcePush: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeCustomEvent? {
    let eventTypeKey = pigeonVar_list[0] as! String
    let dateOccurred = pigeonVar_list[1] as! String
    let parameters = pigeonVar_list[2] as! [NativeCustomEventParameter?]
    let forcePush = pigeonVar_list[3] as! Bool

    return NativeCustomEvent(
      eventTypeKey: eventTypeKey,
      dateOccurred: dateOccurred,
      parameters: parameters,
      forcePush: forcePush
    )
  }
  func toList() -> [Any?] {
    return [
      eventTypeKey,
      dateOccurred,
      parameters,
      forcePush,
    ]
  }
  static func == (lhs: NativeCustomEvent, rhs: NativeCustomEvent) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeCustomEventParameter: Hashable {
  var name: String
  var value: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeCustomEventParameter? {
    let name = pigeonVar_list[0] as! String
    let value: String? = nilOrValue(pigeonVar_list[1])

    return NativeCustomEventParameter(
      name: name,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      value,
    ]
  }
  static func == (lhs: NativeCustomEventParameter, rhs: NativeCustomEventParameter) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeInAppMessageAction: Hashable {
  var isCloseButtonClicked: Bool
  var isButtonClicked: Bool
  var isOpenUrlClicked: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeInAppMessageAction? {
    let isCloseButtonClicked = pigeonVar_list[0] as! Bool
    let isButtonClicked = pigeonVar_list[1] as! Bool
    let isOpenUrlClicked = pigeonVar_list[2] as! Bool

    return NativeInAppMessageAction(
      isCloseButtonClicked: isCloseButtonClicked,
      isButtonClicked: isButtonClicked,
      isOpenUrlClicked: isOpenUrlClicked
    )
  }
  func toList() -> [Any?] {
    return [
      isCloseButtonClicked,
      isButtonClicked,
      isOpenUrlClicked,
    ]
  }
  static func == (lhs: NativeInAppMessageAction, rhs: NativeInAppMessageAction) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecomFilter: Hashable {
  var name: String
  var values: [String?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeRecomFilter? {
    let name = pigeonVar_list[0] as! String
    let values = pigeonVar_list[1] as! [String?]

    return NativeRecomFilter(
      name: name,
      values: values
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      values,
    ]
  }
  static func == (lhs: NativeRecomFilter, rhs: NativeRecomFilter) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecommendation: Hashable {
  var productId: String
  var name: String? = nil
  var description: String? = nil
  var imageUrl: String? = nil
  var price: Double? = nil
  var category: [String]? = nil
  var categoryAncestor: [String]? = nil
  var categoryLayout: [String]? = nil
  var categoryParent: [String]? = nil
  var dateCreatedAs: String? = nil
  var dateCreatedEs: String? = nil
  var dateModifiedAs: String? = nil
  var itemGroup: String? = nil
  var nameKeyword: String? = nil
  var productIdAlt: String? = nil
  var tagsAllCategoryNames: String? = nil
  var tagsBestseller: String? = nil
  var tagsCashback: String? = nil
  var tagsCategoryBestseller: String? = nil
  var tagsCredit: String? = nil
  var tagsDelivery: String? = nil
  var tagsDescriptionPriceRange: String? = nil
  var tagsDiscount: String? = nil
  var tagsHasPurchases21Days: String? = nil
  var tagsIsBestseller: String? = nil
  var tagsIsBestsellerByCategories: String? = nil
  var tagsItemGroupId: String? = nil
  var tagsNumPurchases21Days: String? = nil
  var tagsOldPrice: String? = nil
  var tagsOldprice: String? = nil
  var tagsPriceRange: String? = nil
  var tagsRating: String? = nil
  var tagsSale: String? = nil
  var url: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeRecommendation? {
    let productId = pigeonVar_list[0] as! String
    let name: String? = nilOrValue(pigeonVar_list[1])
    let description: String? = nilOrValue(pigeonVar_list[2])
    let imageUrl: String? = nilOrValue(pigeonVar_list[3])
    let price: Double? = nilOrValue(pigeonVar_list[4])
    let category: [String]? = nilOrValue(pigeonVar_list[5])
    let categoryAncestor: [String]? = nilOrValue(pigeonVar_list[6])
    let categoryLayout: [String]? = nilOrValue(pigeonVar_list[7])
    let categoryParent: [String]? = nilOrValue(pigeonVar_list[8])
    let dateCreatedAs: String? = nilOrValue(pigeonVar_list[9])
    let dateCreatedEs: String? = nilOrValue(pigeonVar_list[10])
    let dateModifiedAs: String? = nilOrValue(pigeonVar_list[11])
    let itemGroup: String? = nilOrValue(pigeonVar_list[12])
    let nameKeyword: String? = nilOrValue(pigeonVar_list[13])
    let productIdAlt: String? = nilOrValue(pigeonVar_list[14])
    let tagsAllCategoryNames: String? = nilOrValue(pigeonVar_list[15])
    let tagsBestseller: String? = nilOrValue(pigeonVar_list[16])
    let tagsCashback: String? = nilOrValue(pigeonVar_list[17])
    let tagsCategoryBestseller: String? = nilOrValue(pigeonVar_list[18])
    let tagsCredit: String? = nilOrValue(pigeonVar_list[19])
    let tagsDelivery: String? = nilOrValue(pigeonVar_list[20])
    let tagsDescriptionPriceRange: String? = nilOrValue(pigeonVar_list[21])
    let tagsDiscount: String? = nilOrValue(pigeonVar_list[22])
    let tagsHasPurchases21Days: String? = nilOrValue(pigeonVar_list[23])
    let tagsIsBestseller: String? = nilOrValue(pigeonVar_list[24])
    let tagsIsBestsellerByCategories: String? = nilOrValue(pigeonVar_list[25])
    let tagsItemGroupId: String? = nilOrValue(pigeonVar_list[26])
    let tagsNumPurchases21Days: String? = nilOrValue(pigeonVar_list[27])
    let tagsOldPrice: String? = nilOrValue(pigeonVar_list[28])
    let tagsOldprice: String? = nilOrValue(pigeonVar_list[29])
    let tagsPriceRange: String? = nilOrValue(pigeonVar_list[30])
    let tagsRating: String? = nilOrValue(pigeonVar_list[31])
    let tagsSale: String? = nilOrValue(pigeonVar_list[32])
    let url: String? = nilOrValue(pigeonVar_list[33])

    return NativeRecommendation(
      productId: productId,
      name: name,
      description: description,
      imageUrl: imageUrl,
      price: price,
      category: category,
      categoryAncestor: categoryAncestor,
      categoryLayout: categoryLayout,
      categoryParent: categoryParent,
      dateCreatedAs: dateCreatedAs,
      dateCreatedEs: dateCreatedEs,
      dateModifiedAs: dateModifiedAs,
      itemGroup: itemGroup,
      nameKeyword: nameKeyword,
      productIdAlt: productIdAlt,
      tagsAllCategoryNames: tagsAllCategoryNames,
      tagsBestseller: tagsBestseller,
      tagsCashback: tagsCashback,
      tagsCategoryBestseller: tagsCategoryBestseller,
      tagsCredit: tagsCredit,
      tagsDelivery: tagsDelivery,
      tagsDescriptionPriceRange: tagsDescriptionPriceRange,
      tagsDiscount: tagsDiscount,
      tagsHasPurchases21Days: tagsHasPurchases21Days,
      tagsIsBestseller: tagsIsBestseller,
      tagsIsBestsellerByCategories: tagsIsBestsellerByCategories,
      tagsItemGroupId: tagsItemGroupId,
      tagsNumPurchases21Days: tagsNumPurchases21Days,
      tagsOldPrice: tagsOldPrice,
      tagsOldprice: tagsOldprice,
      tagsPriceRange: tagsPriceRange,
      tagsRating: tagsRating,
      tagsSale: tagsSale,
      url: url
    )
  }
  func toList() -> [Any?] {
    return [
      productId,
      name,
      description,
      imageUrl,
      price,
      category,
      categoryAncestor,
      categoryLayout,
      categoryParent,
      dateCreatedAs,
      dateCreatedEs,
      dateModifiedAs,
      itemGroup,
      nameKeyword,
      productIdAlt,
      tagsAllCategoryNames,
      tagsBestseller,
      tagsCashback,
      tagsCategoryBestseller,
      tagsCredit,
      tagsDelivery,
      tagsDescriptionPriceRange,
      tagsDiscount,
      tagsHasPurchases21Days,
      tagsIsBestseller,
      tagsIsBestsellerByCategories,
      tagsItemGroupId,
      tagsNumPurchases21Days,
      tagsOldPrice,
      tagsOldprice,
      tagsPriceRange,
      tagsRating,
      tagsSale,
      url,
    ]
  }
  static func == (lhs: NativeRecommendation, rhs: NativeRecommendation) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecomEvent: Hashable {
  var eventType: NativeRecomEventType
  var dateOccurred: String
  var productId: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeRecomEvent? {
    let eventType = pigeonVar_list[0] as! NativeRecomEventType
    let dateOccurred = pigeonVar_list[1] as! String
    let productId = pigeonVar_list[2] as! String

    return NativeRecomEvent(
      eventType: eventType,
      dateOccurred: dateOccurred,
      productId: productId
    )
  }
  func toList() -> [Any?] {
    return [
      eventType,
      dateOccurred,
      productId,
    ]
  }
  static func == (lhs: NativeRecomEvent, rhs: NativeRecomEvent) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeRecomEvents: Hashable {
  var recomVariantId: String
  var events: [NativeRecomEvent?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeRecomEvents? {
    let recomVariantId = pigeonVar_list[0] as! String
    let events = pigeonVar_list[1] as! [NativeRecomEvent?]

    return NativeRecomEvents(
      recomVariantId: recomVariantId,
      events: events
    )
  }
  func toList() -> [Any?] {
    return [
      recomVariantId,
      events,
    ]
  }
  static func == (lhs: NativeRecomEvents, rhs: NativeRecomEvents) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLifecycleTrackingOptions: Hashable {
  var appLifecycleEnabled: Bool
  var pushSubscriptionEnabled: Bool
  var sessionEventsEnabled: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeLifecycleTrackingOptions? {
    let appLifecycleEnabled = pigeonVar_list[0] as! Bool
    let pushSubscriptionEnabled = pigeonVar_list[1] as! Bool
    let sessionEventsEnabled = pigeonVar_list[2] as! Bool

    return NativeLifecycleTrackingOptions(
      appLifecycleEnabled: appLifecycleEnabled,
      pushSubscriptionEnabled: pushSubscriptionEnabled,
      sessionEventsEnabled: sessionEventsEnabled
    )
  }
  func toList() -> [Any?] {
    return [
      appLifecycleEnabled,
      pushSubscriptionEnabled,
      sessionEventsEnabled,
    ]
  }
  static func == (lhs: NativeLifecycleTrackingOptions, rhs: NativeLifecycleTrackingOptions) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAppInboxMessages: Hashable {
  var messages: [NativeAppInboxMessage?]
  var totalPages: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeAppInboxMessages? {
    let messages = pigeonVar_list[0] as! [NativeAppInboxMessage?]
    let totalPages = pigeonVar_list[1] as! Int64

    return NativeAppInboxMessages(
      messages: messages,
      totalPages: totalPages
    )
  }
  func toList() -> [Any?] {
    return [
      messages,
      totalPages,
    ]
  }
  static func == (lhs: NativeAppInboxMessages, rhs: NativeAppInboxMessages) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAppInboxMessage: Hashable {
  var id: String
  var title: String
  var createdDate: String
  var isNewMessage: Bool
  var content: String? = nil
  var imageUrl: String? = nil
  var linkUrl: String? = nil
  var category: String? = nil
  var customData: [String?: Any?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeAppInboxMessage? {
    let id = pigeonVar_list[0] as! String
    let title = pigeonVar_list[1] as! String
    let createdDate = pigeonVar_list[2] as! String
    let isNewMessage = pigeonVar_list[3] as! Bool
    let content: String? = nilOrValue(pigeonVar_list[4])
    let imageUrl: String? = nilOrValue(pigeonVar_list[5])
    let linkUrl: String? = nilOrValue(pigeonVar_list[6])
    let category: String? = nilOrValue(pigeonVar_list[7])
    let customData: [String?: Any?]? = nilOrValue(pigeonVar_list[8])

    return NativeAppInboxMessage(
      id: id,
      title: title,
      createdDate: createdDate,
      isNewMessage: isNewMessage,
      content: content,
      imageUrl: imageUrl,
      linkUrl: linkUrl,
      category: category,
      customData: customData
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      createdDate,
      isNewMessage,
      content,
      imageUrl,
      linkUrl,
      category,
      customData,
    ]
  }
  static func == (lhs: NativeAppInboxMessage, rhs: NativeAppInboxMessage) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserNotificationAction: Hashable {
  var actionId: String? = nil
  var customData: [String?: Any?]? = nil
  var link: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeUserNotificationAction? {
    let actionId: String? = nilOrValue(pigeonVar_list[0])
    let customData: [String?: Any?]? = nilOrValue(pigeonVar_list[1])
    let link: String? = nilOrValue(pigeonVar_list[2])

    return NativeUserNotificationAction(
      actionId: actionId,
      customData: customData,
      link: link
    )
  }
  func toList() -> [Any?] {
    return [
      actionId,
      customData,
      link,
    ]
  }
  static func == (lhs: NativeUserNotificationAction, rhs: NativeUserNotificationAction) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEcommerceProduct: Hashable {
  var productId: String
  var price: Double
  var inStock: Bool
  var attributes: [String?: [String]?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeEcommerceProduct? {
    let productId = pigeonVar_list[0] as! String
    let price = pigeonVar_list[1] as! Double
    let inStock = pigeonVar_list[2] as! Bool
    let attributes: [String?: [String]?]? = nilOrValue(pigeonVar_list[3])

    return NativeEcommerceProduct(
      productId: productId,
      price: price,
      inStock: inStock,
      attributes: attributes
    )
  }
  func toList() -> [Any?] {
    return [
      productId,
      price,
      inStock,
      attributes,
    ]
  }
  static func == (lhs: NativeEcommerceProduct, rhs: NativeEcommerceProduct) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEcommerceCategory: Hashable {
  var productCategoryId: String
  var attributes: [String?: [String]?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeEcommerceCategory? {
    let productCategoryId = pigeonVar_list[0] as! String
    let attributes: [String?: [String]?]? = nilOrValue(pigeonVar_list[1])

    return NativeEcommerceCategory(
      productCategoryId: productCategoryId,
      attributes: attributes
    )
  }
  func toList() -> [Any?] {
    return [
      productCategoryId,
      attributes,
    ]
  }
  static func == (lhs: NativeEcommerceCategory, rhs: NativeEcommerceCategory) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEcommerceProductInCart: Hashable {
  var productId: String
  var price: Double
  var quantity: Int64
  var discount: Double? = nil
  var name: String? = nil
  var category: String? = nil
  var attributes: [String?: [String]?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeEcommerceProductInCart? {
    let productId = pigeonVar_list[0] as! String
    let price = pigeonVar_list[1] as! Double
    let quantity = pigeonVar_list[2] as! Int64
    let discount: Double? = nilOrValue(pigeonVar_list[3])
    let name: String? = nilOrValue(pigeonVar_list[4])
    let category: String? = nilOrValue(pigeonVar_list[5])
    let attributes: [String?: [String]?]? = nilOrValue(pigeonVar_list[6])

    return NativeEcommerceProductInCart(
      productId: productId,
      price: price,
      quantity: quantity,
      discount: discount,
      name: name,
      category: category,
      attributes: attributes
    )
  }
  func toList() -> [Any?] {
    return [
      productId,
      price,
      quantity,
      discount,
      name,
      category,
      attributes,
    ]
  }
  static func == (lhs: NativeEcommerceProductInCart, rhs: NativeEcommerceProductInCart) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEcommerceItem: Hashable {
  var externalItemId: String
  var name: String
  var category: String
  var quantity: Double
  var cost: Double
  var url: String
  var imageUrl: String? = nil
  var description: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeEcommerceItem? {
    let externalItemId = pigeonVar_list[0] as! String
    let name = pigeonVar_list[1] as! String
    let category = pigeonVar_list[2] as! String
    let quantity = pigeonVar_list[3] as! Double
    let cost = pigeonVar_list[4] as! Double
    let url = pigeonVar_list[5] as! String
    let imageUrl: String? = nilOrValue(pigeonVar_list[6])
    let description: String? = nilOrValue(pigeonVar_list[7])

    return NativeEcommerceItem(
      externalItemId: externalItemId,
      name: name,
      category: category,
      quantity: quantity,
      cost: cost,
      url: url,
      imageUrl: imageUrl,
      description: description
    )
  }
  func toList() -> [Any?] {
    return [
      externalItemId,
      name,
      category,
      quantity,
      cost,
      url,
      imageUrl,
      description,
    ]
  }
  static func == (lhs: NativeEcommerceItem, rhs: NativeEcommerceItem) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEcommerceOrder: Hashable {
  var externalOrderId: String
  var totalCost: Double
  var status: String
  var date: String
  var cartId: String? = nil
  var email: String? = nil
  var phone: String? = nil
  var firstName: String? = nil
  var lastName: String? = nil
  var shipping: Double? = nil
  var discount: Double? = nil
  var taxes: Double? = nil
  var restoreUrl: String? = nil
  var statusDescription: String? = nil
  var storeId: String? = nil
  var source: String? = nil
  var deliveryMethod: String? = nil
  var paymentMethod: String? = nil
  var deliveryAddress: String? = nil
  var items: [NativeEcommerceItem?]? = nil
  var attributes: [String?: [String]?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeEcommerceOrder? {
    let externalOrderId = pigeonVar_list[0] as! String
    let totalCost = pigeonVar_list[1] as! Double
    let status = pigeonVar_list[2] as! String
    let date = pigeonVar_list[3] as! String
    let cartId: String? = nilOrValue(pigeonVar_list[4])
    let email: String? = nilOrValue(pigeonVar_list[5])
    let phone: String? = nilOrValue(pigeonVar_list[6])
    let firstName: String? = nilOrValue(pigeonVar_list[7])
    let lastName: String? = nilOrValue(pigeonVar_list[8])
    let shipping: Double? = nilOrValue(pigeonVar_list[9])
    let discount: Double? = nilOrValue(pigeonVar_list[10])
    let taxes: Double? = nilOrValue(pigeonVar_list[11])
    let restoreUrl: String? = nilOrValue(pigeonVar_list[12])
    let statusDescription: String? = nilOrValue(pigeonVar_list[13])
    let storeId: String? = nilOrValue(pigeonVar_list[14])
    let source: String? = nilOrValue(pigeonVar_list[15])
    let deliveryMethod: String? = nilOrValue(pigeonVar_list[16])
    let paymentMethod: String? = nilOrValue(pigeonVar_list[17])
    let deliveryAddress: String? = nilOrValue(pigeonVar_list[18])
    let items: [NativeEcommerceItem?]? = nilOrValue(pigeonVar_list[19])
    let attributes: [String?: [String]?]? = nilOrValue(pigeonVar_list[20])

    return NativeEcommerceOrder(
      externalOrderId: externalOrderId,
      totalCost: totalCost,
      status: status,
      date: date,
      cartId: cartId,
      email: email,
      phone: phone,
      firstName: firstName,
      lastName: lastName,
      shipping: shipping,
      discount: discount,
      taxes: taxes,
      restoreUrl: restoreUrl,
      statusDescription: statusDescription,
      storeId: storeId,
      source: source,
      deliveryMethod: deliveryMethod,
      paymentMethod: paymentMethod,
      deliveryAddress: deliveryAddress,
      items: items,
      attributes: attributes
    )
  }
  func toList() -> [Any?] {
    return [
      externalOrderId,
      totalCost,
      status,
      date,
      cartId,
      email,
      phone,
      firstName,
      lastName,
      shipping,
      discount,
      taxes,
      restoreUrl,
      statusDescription,
      storeId,
      source,
      deliveryMethod,
      paymentMethod,
      deliveryAddress,
      items,
      attributes,
    ]
  }
  static func == (lhs: NativeEcommerceOrder, rhs: NativeEcommerceOrder) -> Bool {
    return deepEqualsRetenoNativePlugin(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashRetenoNativePlugin(value: toList(), hasher: &hasher)
  }
}

private class RetenoNativePluginPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NativeInAppMessageStatus(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NativeRecomEventType(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      return NativeRetenoUser.fromList(self.readValue() as! [Any?])
    case 132:
      return NativeUserAttributes.fromList(self.readValue() as! [Any?])
    case 133:
      return NativeAddress.fromList(self.readValue() as! [Any?])
    case 134:
      return NativeUserCustomField.fromList(self.readValue() as! [Any?])
    case 135:
      return NativeAnonymousUserAttributes.fromList(self.readValue() as! [Any?])
    case 136:
      return NativeCustomEvent.fromList(self.readValue() as! [Any?])
    case 137:
      return NativeCustomEventParameter.fromList(self.readValue() as! [Any?])
    case 138:
      return NativeInAppMessageAction.fromList(self.readValue() as! [Any?])
    case 139:
      return NativeRecomFilter.fromList(self.readValue() as! [Any?])
    case 140:
      return NativeRecommendation.fromList(self.readValue() as! [Any?])
    case 141:
      return NativeRecomEvent.fromList(self.readValue() as! [Any?])
    case 142:
      return NativeRecomEvents.fromList(self.readValue() as! [Any?])
    case 143:
      return NativeLifecycleTrackingOptions.fromList(self.readValue() as! [Any?])
    case 144:
      return NativeAppInboxMessages.fromList(self.readValue() as! [Any?])
    case 145:
      return NativeAppInboxMessage.fromList(self.readValue() as! [Any?])
    case 146:
      return NativeUserNotificationAction.fromList(self.readValue() as! [Any?])
    case 147:
      return NativeEcommerceProduct.fromList(self.readValue() as! [Any?])
    case 148:
      return NativeEcommerceCategory.fromList(self.readValue() as! [Any?])
    case 149:
      return NativeEcommerceProductInCart.fromList(self.readValue() as! [Any?])
    case 150:
      return NativeEcommerceItem.fromList(self.readValue() as! [Any?])
    case 151:
      return NativeEcommerceOrder.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class RetenoNativePluginPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? NativeInAppMessageStatus {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? NativeRecomEventType {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? NativeRetenoUser {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserAttributes {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAddress {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserCustomField {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAnonymousUserAttributes {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? NativeCustomEvent {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? NativeCustomEventParameter {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? NativeInAppMessageAction {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomFilter {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecommendation {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomEvent {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? NativeRecomEvents {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLifecycleTrackingOptions {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAppInboxMessages {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAppInboxMessage {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserNotificationAction {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEcommerceProduct {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEcommerceCategory {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEcommerceProductInCart {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEcommerceItem {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEcommerceOrder {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RetenoNativePluginPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RetenoNativePluginPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RetenoNativePluginPigeonCodecWriter(data: data)
  }
}

class RetenoNativePluginPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = RetenoNativePluginPigeonCodec(readerWriter: RetenoNativePluginPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol RetenoHostApi {
  func initWith(accessKey: String, lifecycleTrackingOptions: NativeLifecycleTrackingOptions?, isPausedInAppMessages: Bool, useCustomDeviceIdProvider: Bool, isDebug: Bool) throws
  func setUserAttributes(externalUserId: String, user: NativeRetenoUser?) throws
  func setAnonymousUserAttributes(anonymousUserAttributes: NativeAnonymousUserAttributes) throws
  func logEvent(event: NativeCustomEvent) throws
  func updatePushPermissionStatus() throws
  func pauseInAppMessages(isPaused: Bool) throws
  func getInitialNotification() throws -> [String: Any]?
  func getRecommendations(recomVariantId: String, productIds: [String], categoryId: String?, filters: [NativeRecomFilter]?, fields: [String]?, completion: @escaping (Result<[NativeRecommendation], Error>) -> Void)
  func logRecommendationsEvent(events: NativeRecomEvents) throws
  func getAppInboxMessages(page: Int64?, pageSize: Int64?, completion: @escaping (Result<NativeAppInboxMessages, Error>) -> Void)
  func getAppInboxMessagesCount(completion: @escaping (Result<Int64, Error>) -> Void)
  func markAsOpened(messageId: String) throws
  func markAllMessagesAsOpened(completion: @escaping (Result<Void, Error>) -> Void)
  func subscribeOnMessagesCountChanged() throws
  func unsubscribeAllMessagesCountChanged() throws
  func logEcommerceProductViewed(product: NativeEcommerceProduct, currency: String?) throws
  func logEcommerceProductCategoryViewed(category: NativeEcommerceCategory) throws
  func logEcommerceProductAddedToWishlist(product: NativeEcommerceProduct, currency: String?) throws
  func logEcommerceCartUpdated(cartId: String, products: [NativeEcommerceProductInCart], currency: String?) throws
  func logEcommerceOrderCreated(order: NativeEcommerceOrder, currency: String?) throws
  func logEcommerceOrderUpdated(order: NativeEcommerceOrder, currency: String?) throws
  func logEcommerceOrderDelivered(externalOrderId: String) throws
  func logEcommerceOrderCancelled(externalOrderId: String) throws
  func logEcommerceSearchRequest(query: String, isFound: Bool?) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class RetenoHostApiSetup {
  static var codec: FlutterStandardMessageCodec { RetenoNativePluginPigeonCodec.shared }
  /// Sets up an instance of `RetenoHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: RetenoHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initWithChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.initWith\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initWithChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let accessKeyArg = args[0] as! String
        let lifecycleTrackingOptionsArg: NativeLifecycleTrackingOptions? = nilOrValue(args[1])
        let isPausedInAppMessagesArg = args[2] as! Bool
        let useCustomDeviceIdProviderArg = args[3] as! Bool
        let isDebugArg = args[4] as! Bool
        do {
          try api.initWith(accessKey: accessKeyArg, lifecycleTrackingOptions: lifecycleTrackingOptionsArg, isPausedInAppMessages: isPausedInAppMessagesArg, useCustomDeviceIdProvider: useCustomDeviceIdProviderArg, isDebug: isDebugArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initWithChannel.setMessageHandler(nil)
    }
    let setUserAttributesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.setUserAttributes\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUserAttributesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let externalUserIdArg = args[0] as! String
        let userArg: NativeRetenoUser? = nilOrValue(args[1])
        do {
          try api.setUserAttributes(externalUserId: externalUserIdArg, user: userArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserAttributesChannel.setMessageHandler(nil)
    }
    let setAnonymousUserAttributesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.setAnonymousUserAttributes\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAnonymousUserAttributesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let anonymousUserAttributesArg = args[0] as! NativeAnonymousUserAttributes
        do {
          try api.setAnonymousUserAttributes(anonymousUserAttributes: anonymousUserAttributesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAnonymousUserAttributesChannel.setMessageHandler(nil)
    }
    let logEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEvent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! NativeCustomEvent
        do {
          try api.logEvent(event: eventArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEventChannel.setMessageHandler(nil)
    }
    let updatePushPermissionStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.updatePushPermissionStatus\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updatePushPermissionStatusChannel.setMessageHandler { _, reply in
        do {
          try api.updatePushPermissionStatus()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updatePushPermissionStatusChannel.setMessageHandler(nil)
    }
    let pauseInAppMessagesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.pauseInAppMessages\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseInAppMessagesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let isPausedArg = args[0] as! Bool
        do {
          try api.pauseInAppMessages(isPaused: isPausedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseInAppMessagesChannel.setMessageHandler(nil)
    }
    let getInitialNotificationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getInitialNotification\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getInitialNotificationChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getInitialNotification()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getInitialNotificationChannel.setMessageHandler(nil)
    }
    let getRecommendationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getRecommendations\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getRecommendationsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let recomVariantIdArg = args[0] as! String
        let productIdsArg = args[1] as! [String]
        let categoryIdArg: String? = nilOrValue(args[2])
        let filtersArg: [NativeRecomFilter]? = nilOrValue(args[3])
        let fieldsArg: [String]? = nilOrValue(args[4])
        api.getRecommendations(recomVariantId: recomVariantIdArg, productIds: productIdsArg, categoryId: categoryIdArg, filters: filtersArg, fields: fieldsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getRecommendationsChannel.setMessageHandler(nil)
    }
    let logRecommendationsEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logRecommendationsEvent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logRecommendationsEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventsArg = args[0] as! NativeRecomEvents
        do {
          try api.logRecommendationsEvent(events: eventsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logRecommendationsEventChannel.setMessageHandler(nil)
    }
    let getAppInboxMessagesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getAppInboxMessages\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAppInboxMessagesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pageArg: Int64? = nilOrValue(args[0])
        let pageSizeArg: Int64? = nilOrValue(args[1])
        api.getAppInboxMessages(page: pageArg, pageSize: pageSizeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAppInboxMessagesChannel.setMessageHandler(nil)
    }
    let getAppInboxMessagesCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.getAppInboxMessagesCount\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAppInboxMessagesCountChannel.setMessageHandler { _, reply in
        api.getAppInboxMessagesCount { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAppInboxMessagesCountChannel.setMessageHandler(nil)
    }
    let markAsOpenedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.markAsOpened\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      markAsOpenedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let messageIdArg = args[0] as! String
        do {
          try api.markAsOpened(messageId: messageIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      markAsOpenedChannel.setMessageHandler(nil)
    }
    let markAllMessagesAsOpenedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.markAllMessagesAsOpened\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      markAllMessagesAsOpenedChannel.setMessageHandler { _, reply in
        api.markAllMessagesAsOpened { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      markAllMessagesAsOpenedChannel.setMessageHandler(nil)
    }
    let subscribeOnMessagesCountChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.subscribeOnMessagesCountChanged\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      subscribeOnMessagesCountChangedChannel.setMessageHandler { _, reply in
        do {
          try api.subscribeOnMessagesCountChanged()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      subscribeOnMessagesCountChangedChannel.setMessageHandler(nil)
    }
    let unsubscribeAllMessagesCountChangedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.unsubscribeAllMessagesCountChanged\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unsubscribeAllMessagesCountChangedChannel.setMessageHandler { _, reply in
        do {
          try api.unsubscribeAllMessagesCountChanged()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unsubscribeAllMessagesCountChangedChannel.setMessageHandler(nil)
    }
    let logEcommerceProductViewedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceProductViewed\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceProductViewedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let productArg = args[0] as! NativeEcommerceProduct
        let currencyArg: String? = nilOrValue(args[1])
        do {
          try api.logEcommerceProductViewed(product: productArg, currency: currencyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceProductViewedChannel.setMessageHandler(nil)
    }
    let logEcommerceProductCategoryViewedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceProductCategoryViewed\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceProductCategoryViewedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let categoryArg = args[0] as! NativeEcommerceCategory
        do {
          try api.logEcommerceProductCategoryViewed(category: categoryArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceProductCategoryViewedChannel.setMessageHandler(nil)
    }
    let logEcommerceProductAddedToWishlistChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceProductAddedToWishlist\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceProductAddedToWishlistChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let productArg = args[0] as! NativeEcommerceProduct
        let currencyArg: String? = nilOrValue(args[1])
        do {
          try api.logEcommerceProductAddedToWishlist(product: productArg, currency: currencyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceProductAddedToWishlistChannel.setMessageHandler(nil)
    }
    let logEcommerceCartUpdatedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceCartUpdated\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceCartUpdatedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cartIdArg = args[0] as! String
        let productsArg = args[1] as! [NativeEcommerceProductInCart]
        let currencyArg: String? = nilOrValue(args[2])
        do {
          try api.logEcommerceCartUpdated(cartId: cartIdArg, products: productsArg, currency: currencyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceCartUpdatedChannel.setMessageHandler(nil)
    }
    let logEcommerceOrderCreatedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceOrderCreated\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceOrderCreatedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let orderArg = args[0] as! NativeEcommerceOrder
        let currencyArg: String? = nilOrValue(args[1])
        do {
          try api.logEcommerceOrderCreated(order: orderArg, currency: currencyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceOrderCreatedChannel.setMessageHandler(nil)
    }
    let logEcommerceOrderUpdatedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceOrderUpdated\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceOrderUpdatedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let orderArg = args[0] as! NativeEcommerceOrder
        let currencyArg: String? = nilOrValue(args[1])
        do {
          try api.logEcommerceOrderUpdated(order: orderArg, currency: currencyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceOrderUpdatedChannel.setMessageHandler(nil)
    }
    let logEcommerceOrderDeliveredChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceOrderDelivered\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceOrderDeliveredChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let externalOrderIdArg = args[0] as! String
        do {
          try api.logEcommerceOrderDelivered(externalOrderId: externalOrderIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceOrderDeliveredChannel.setMessageHandler(nil)
    }
    let logEcommerceOrderCancelledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceOrderCancelled\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceOrderCancelledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let externalOrderIdArg = args[0] as! String
        do {
          try api.logEcommerceOrderCancelled(externalOrderId: externalOrderIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceOrderCancelledChannel.setMessageHandler(nil)
    }
    let logEcommerceSearchRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.reteno_plugin.RetenoHostApi.logEcommerceSearchRequest\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logEcommerceSearchRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let queryArg = args[0] as! String
        let isFoundArg: Bool? = nilOrValue(args[1])
        do {
          try api.logEcommerceSearchRequest(query: queryArg, isFound: isFoundArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      logEcommerceSearchRequestChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol RetenoFlutterApiProtocol {
  func onNotificationReceived(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onNotificationClicked(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onNotificationActionHandler(action actionArg: NativeUserNotificationAction, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onInAppMessageStatusChanged(status statusArg: NativeInAppMessageStatus, action actionArg: NativeInAppMessageAction?, error errorArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onMessagesCountChanged(count countArg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func getDeviceId(completion: @escaping (Result<String?, PigeonError>) -> Void)
}
class RetenoFlutterApi: RetenoFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: RetenoNativePluginPigeonCodec {
    return RetenoNativePluginPigeonCodec.shared
  }
  func onNotificationReceived(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onNotificationReceived\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([payloadArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onNotificationClicked(payload payloadArg: [String: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onNotificationClicked\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([payloadArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onNotificationActionHandler(action actionArg: NativeUserNotificationAction, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onNotificationActionHandler\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([actionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onInAppMessageStatusChanged(status statusArg: NativeInAppMessageStatus, action actionArg: NativeInAppMessageAction?, error errorArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onInAppMessageStatusChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([statusArg, actionArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onMessagesCountChanged(count countArg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.onMessagesCountChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([countArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func getDeviceId(completion: @escaping (Result<String?, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.reteno_plugin.RetenoFlutterApi.getDeviceId\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        let result: String? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }
}
